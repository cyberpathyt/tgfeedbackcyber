import os
import gspread
import re
from datetime import datetime, timedelta
from aiogram import Bot, Dispatcher, types
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher.filters import BoundFilter
from aiogram.utils.exceptions import Throttled
from collections import Counter
import logging
from fastapi import FastAPI, Request
import uvicorn
import asyncio
from contextlib import asynccontextmanager
from fastapi.responses import JSONResponse

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('bot.log')
    ]
)
logger = logging.getLogger(__name__)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ —Å —è–≤–Ω—ã–º —É–∫–∞–∑–∞–Ω–∏–µ–º —Ö—Ä–∞–Ω–∏–ª–∏—â–∞
storage = MemoryStorage()
bot = Bot(token=os.getenv('TELEGRAM_TOKEN'))
Bot.set_current(bot)
dp = Dispatcher(bot, storage=storage)

class Config:
    """–ö–ª–∞—Å—Å –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"""
    def __init__(self):
        self.required_vars = [
            'TELEGRAM_TOKEN',
            'GOOGLE_SHEET_URL',
            'GS_TYPE',
            'GS_PROJECT_ID',
            'GS_PRIVATE_KEY_ID',
            'GS_PRIVATE_KEY',
            'GS_CLIENT_EMAIL',
            'GS_CLIENT_ID'
        ]
        self.check_config()
        
    def check_config(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ –≤—Å–µ—Ö –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è"""
        missing_vars = [var for var in self.required_vars if not os.getenv(var)]
        if missing_vars:
            error_msg = f"–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è: {', '.join(missing_vars)}"
            logger.critical(error_msg)
            raise EnvironmentError(error_msg)
        logger.info("–í—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –Ω–∞–π–¥–µ–Ω—ã")

config = Config()

class YouTubeFilter(BoundFilter):
    """–§–∏–ª—å—Ç—Ä –¥–ª—è YouTube —Å—Å—ã–ª–æ–∫"""
    async def check(self, message: types.Message) -> bool:
        if not message.text or message.text.startswith('/'):
            return False
            
        patterns = [
            r'(?:https?://)?(?:www\.)?youtube\.com/watch\?v=([^&\s]+)',
            r'(?:https?://)?(?:www\.)?youtu\.be/([^?\s]+)',
            r'(?:https?://)?(?:www\.)?youtube\.com/shorts/([^?\s]+)',
            r'(?:https?://)?(?:www\.)?youtube\.com/embed/([^?\s]+)',
            r'(?:https?://)?(?:www\.)?youtube\.com/live/([^?\s]+)'
        ]
        
        return any(re.search(pattern, message.text, re.IGNORECASE) for pattern in patterns)

dp.filters_factory.bind(YouTubeFilter)

class GoogleSheetsManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Google Sheets"""
    def __init__(self):
        self.credentials = self._get_credentials()
        self.sheet_url = os.getenv('GOOGLE_SHEET_URL')
        
    def _get_credentials(self) -> dict:
        """–°–æ–∑–¥–∞–µ—Ç credentials –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è"""
        return {
            "type": os.getenv('GS_TYPE'),
            "project_id": os.getenv('GS_PROJECT_ID'),
            "private_key_id": os.getenv('GS_PRIVATE_KEY_ID'),
            "private_key": os.getenv('GS_PRIVATE_KEY').replace('\\n', '\n'),
            "client_email": os.getenv('GS_CLIENT_EMAIL'),
            "client_id": os.getenv('GS_CLIENT_ID'),
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": os.getenv('GS_CLIENT_CERT_URL', '')
        }
        
    def get_sheet(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–∞–±–æ—á–∏–π –ª–∏—Å—Ç —Ç–∞–±–ª–∏—Ü—ã"""
        try:
            gc = gspread.service_account_from_dict(self.credentials)
            sh = gc.open_by_url(self.sheet_url)
            return sh.sheet1
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ Google Sheets: {e}")
            raise

sheets_manager = GoogleSheetsManager()

def is_recent(date_str: str, days: int = 30) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –¥–∞—Ç–∞ –Ω–µ —Å—Ç–∞—Ä—à–µ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –¥–Ω–µ–π"""
    if not date_str:
        return False
        
    for fmt in ('%Y-%m-%d %H:%M:%S', '%d.%m.%Y %H:%M:%S', '%m/%d/%Y %H:%M:%S'):
        try:
            date = datetime.strptime(date_str, fmt)
            return (datetime.now() - date) < timedelta(days=days)
        except ValueError:
            continue
    return False

def get_user_rank(user_id: int) -> int:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–π—Ç–∏–Ω–≥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        sheet = sheets_manager.get_sheet()
        records = sheet.get_all_records()
        
        if not records or 'User ID' not in records[0]:
            logger.error("–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ç–∞–±–ª–∏—Ü—ã: –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∫–æ–ª–æ–Ω–∫–∞ 'User ID'")
            return 0
            
        counts = Counter(str(row['User ID']) for row in records)
        sorted_users = sorted(counts.items(), key=lambda x: (-x[1], x[0]))
        
        user_id_str = str(user_id)
        for rank, (uid, _) in enumerate(sorted_users, 1):
            if uid == user_id_str:
                return rank
        return 0
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ —Ä–µ–π—Ç–∏–Ω–≥–∞: {e}")
        return 0

# –ù–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∞–Ω—Ç–∏—Å–ø–∞–º–∞ –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è throttled
async def check_spam(message: types.Message):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–ø–∞–º —Å –ø—Ä–æ—Å—Ç–æ–π –∑–∞–¥–µ—Ä–∂–∫–æ–π"""
    user_id = message.from_user.id
    last_message = storage.data.get(f'spam_{user_id}')
    
    if last_message and (datetime.now() - last_message).seconds < 2:
        await message.reply("‚ö†Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Å–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ.")
        return True
    
    storage.data[f'spam_{user_id}'] = datetime.now()
    return False

@dp.message_handler(commands=['start', 'help'])
async def send_help(message: types.Message):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥ start –∏ help"""
    if await check_spam(message):
        return
        
    help_text = (
        "ü§ñ <b>YouTube Links Collector Bot</b>\n\n"
        "–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ YouTube –≤–∏–¥–µ–æ, –∏ —è —Å–æ—Ö—Ä–∞–Ω—é –µ—ë –≤ –±–∞–∑—É.\n\n"
        "<b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>\n"
        "/stats - –í–∞—à–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n"
        "/test - –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞"
    )
    await message.answer(help_text, parse_mode='HTML')

@dp.message_handler(commands=['stats'])
async def send_stats(message: types.Message):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã stats"""
    if await check_spam(message):
        return
        
    try:
        user = message.from_user
        logger.info(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ /stats –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.id} ({user.username})")
        
        stats = await generate_stats(user.id)
        await message.answer(stats, parse_mode='HTML')
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ /stats: {e}")
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")

async def generate_stats(user_id: int) -> str:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        sheet = sheets_manager.get_sheet()
        records = sheet.get_all_records()
        
        if not records:
            return "üìä –í –±–∞–∑–µ –ø–æ–∫–∞ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
            
        user_data = [row for row in records if str(row.get('User ID', '')) == str(user_id)]
        monthly = sum(1 for d in user_data if is_recent(d.get('Date', '')))
        rank = get_user_rank(user_id)
        
        return (
            f"üìä <b>–í–∞—à–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</b>:\n"
            f"‚îú –í—Å–µ–≥–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π: <code>{len(user_data)}</code>\n"
            f"‚îú –ó–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 30 –¥–Ω–µ–π: <code>{monthly}</code>\n"
            f"‚îî –í–∞—à —Ä–µ–π—Ç–∏–Ω–≥: <code>{rank}</code> –º–µ—Å—Ç–æ"
        )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")
        return "üìä –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"

@dp.message_handler(YouTubeFilter())
async def handle_youtube(message: types.Message):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ YouTube —Å—Å—ã–ª–æ–∫"""
    if await check_spam(message):
        return
        
    try:
        user = message.from_user
        sheet = sheets_manager.get_sheet()
        url = message.text.split('?')[0].split('&')[0]
        
        sheet.append_row([
            user.username or "–ê–Ω–æ–Ω–∏–º",
            user.id,
            url,
            datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        ])
        
        stats = await generate_stats(user.id)
        await message.answer(f"‚úÖ –°—Å—ã–ª–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!\n{stats}", parse_mode='HTML')
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—Å—ã–ª–∫–∏: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Å—Å—ã–ª–∫–∏")

@dp.message_handler(commands=['test'])
async def test_command(message: types.Message):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –±–æ—Ç–∞"""
    if await check_spam(message):
        return
        
    try:
        sheet = sheets_manager.get_sheet()
        records = sheet.get_all_records()
        user = message.from_user
        
        response = (
            f"üõ† <b>–¢–µ—Å—Ç —Å–∏—Å—Ç–µ–º—ã</b>\n"
            f"‚Ä¢ –ë–æ—Ç: <code>{(await bot.get_me()).username}</code>\n"
            f"‚Ä¢ –¢–∞–±–ª–∏—Ü–∞: <code>{sheet.title}</code>\n"
            f"‚Ä¢ –ó–∞–ø–∏—Å–µ–π: <code>{len(records)}</code>\n"
            f"‚Ä¢ –í–∞—à ID: <code>{user.id}</code>\n"
            f"–°—Ç–∞—Ç—É—Å: <b>—Ä–∞–±–æ—Ç–∞–µ—Ç</b> ‚úÖ"
        )
        await message.answer(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ /test: {e}")
        await message.answer("‚ùå –¢–µ—Å—Ç –Ω–µ –ø—Ä–æ–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.")

@dp.message_handler(content_types=types.ContentTypes.TEXT)
async def handle_text(message: types.Message):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
    if await check_spam(message):
        return
        
    if message.text.startswith('/'):
        await message.answer("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help")
    else:
        await message.answer("üö´ –Ø –ø—Ä–∏–Ω–∏–º–∞—é —Ç–æ–ª—å–∫–æ YouTube-—Å—Å—ã–ª–∫–∏")
        await message.delete()

async def setup_webhook():
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ webhook"""
    try:
        webhook_url = f"{os.getenv('RENDER_EXTERNAL_URL')}/webhook"
        await bot.delete_webhook()
        await bot.set_webhook(webhook_url)
        logger.info(f"Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {webhook_url}")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ webhook: {e}")
        raise

@asynccontextmanager
async def lifespan(app: FastAPI):
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    await setup_webhook()
    logger.info("–°–µ—Ä–≤–∏—Å –∑–∞–ø—É—â–µ–Ω")
    yield
    await bot.session.close()
    logger.info("–°–µ—Ä–≤–∏—Å –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

app = FastAPI(lifespan=lifespan)

@app.post("/webhook")
async def handle_webhook(request: Request):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ webhook"""
    try:
        update = await request.json()
        telegram_update = types.Update(**update)
        await dp.process_update(telegram_update)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ webhook: {e}")
    return {"status": "ok"}

@app.get("/")
async def health_check():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏"""
    return JSONResponse(content={"status": "ok", "bot": "running"})

if __name__ == "__main__":
    port = int(os.getenv("PORT", 10000))
    uvicorn.run(app, host="0.0.0.0", port=port)
